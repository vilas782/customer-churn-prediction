# -*- coding: utf-8 -*-
"""Mini Project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YJRpX6Tq5nFcfImP2TczOcZRDZueGr0O

Mini  Project On Customer Churn Prediction
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import LabelEncoder
from imblearn.over_sampling import SMOTE
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from xgboost import XGBClassifier
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
import pickle

df = pd.read_csv("/content/WA_Fn-UseC_-Telco-Customer-Churn.csv")

df.shape

df.head()

df.head(2)

df.info()

pd.set_option("display.max_columns", None)

df = df.drop(columns=["customerID"])

df.head()

df.columns

print(df["gender"].unique())

print(df["SeniorCitizen"].unique())

print(df["TotalCharges"].unique())

for col in df.columns:
    print(col, df[col].unique())
    print("-"*50)

print(df.isnull().sum())

df[df["TotalCharges"]==" "]

len(df[df["TotalCharges"]==" "])

df["TotalCharges"] = df["TotalCharges"].replace({" ": "0.0"})

df["TotalCharges"] = df["TotalCharges"].astype(float)

df.info()

print(df["Churn"].value_counts())

df.shape

df.columns

df.head(2)

df.describe()

import matplotlib.pyplot as plt
import seaborn as sns

def plot_histogram(df, column_name):

  plt.figure(figsize=(5, 3))
  sns.histplot(df[column_name], kde=True)
  plt.title(f"Distribution of {column_name}")

  # calculate the mean and median values for the columns
  col_mean = df[column_name].mean()
  col_median = df[column_name].median()

  # add vertical lines for mean and median
  plt.axvline(col_mean, color="red", linestyle="--", label="Mean")
  plt.axvline(col_median, color="green", linestyle="-", label="Median")

  plt.legend()

  plt.show()

plot_histogram(df, "tenure")

plot_histogram(df, "MonthlyCharges")

# Before plotting, ensure TotalCharges is numeric
df["TotalCharges"] = df["TotalCharges"].replace({" ": "0.0"})
df["TotalCharges"] = df["TotalCharges"].astype(float)

plot_histogram(df, "TotalCharges")

def plot_boxplot(df, column_name):

  plt.figure(figsize=(5, 3))
  sns.boxplot(y=df[column_name])
  plt.title(f"Box Plot of {column_name}")
  plt.ylabel(column_name)
  plt.show

plot_boxplot(df, "tenure")

plot_boxplot(df, "MonthlyCharges")

plot_boxplot(df, "TotalCharges")

plt.figure(figsize=(8, 4))
sns.heatmap(df[["tenure", "MonthlyCharges", "TotalCharges"]].corr(), annot=True, cmap="coolwarm", fmt=".2f")
plt.title("Correlation Heatmap")
plt.show()

df.columns

df.info()

object_cols = df.select_dtypes(include="object").columns.to_list()

object_cols = ["SeniorCitizen"] + object_cols

for col in object_cols:
  plt.figure(figsize=(5, 3))
  sns.countplot(x=df[col])
  plt.title(f"Count Plot of {col}")
  plt.show()

df["Churn"]=df["Churn"].replace({"Yes":1,"No":0})

df.head(3)

df["Churn"].value_counts()

# identifying columns with object data type
object_columns = df.select_dtypes(include="object").columns

print(object_columns)

#initialize a dictionary to save the encoders
encoders = {}

# apply label encoding and store the encoders
for column in object_columns:
  label_encoder = LabelEncoder()
  df[column] = label_encoder.fit_transform(df[column])
  encoders[column] = label_encoder


# save the encoders to a pickle file
with open("encoders.pkl", "wb") as f:
  pickle.dump(encoders, f)

encoders

df.tail()

# splitting the features and target
X = df.drop(columns=["Churn"])
y = df["Churn"]

# split training and test data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

print(y_train.shape)

print(y_train.value_counts())

smote = SMOTE(random_state=42)

X_train_smote, y_train_smote = smote.fit_resample(X_train, y_train)

print(y_train_smote.value_counts())

# dictionary of models
models = {
    "Decision Tree": DecisionTreeClassifier(random_state=42),
    "Random Forest": RandomForestClassifier(random_state=42),
    "XGBoost": XGBClassifier(random_state=42)
}

# dictionary to store the cross validation results
cv_scores = {}

# perform 5-fold cross validation for each model
for model_name, model in models.items():
  print(f"Training {model_name} with default parameters")
  scores = cross_val_score(model, X_train_smote, y_train_smote, cv=5, scoring="accuracy")
  cv_scores[model_name] = scores
  print(f"{model_name} cross-validation accuracy: {np.mean(scores):.2f}")
  print("-"*70)

cv_scores

rfc=RandomForestClassifier(random_state=42)

rfc.fit(X_train_smote, y_train_smote)

print(y_test.value_counts())

# evaluate on test data
y_test_pred = rfc.predict(X_test)

print("Accuracy Score:\n", accuracy_score(y_test, y_test_pred))
print("Confsuion Matrix:\n", confusion_matrix(y_test, y_test_pred))
print("Classification Report:\n", classification_report(y_test, y_test_pred))

# save the trained model as a pickle file
model_data = {"model": rfc, "features_names": X.columns.tolist()}


with open("customer_churn_model.pkl", "wb") as f:
  pickle.dump(model_data, f)

# load the saved model and the feature names

with open("customer_churn_model.pkl", "rb") as f:
  model_data = pickle.load(f)

loaded_model = model_data["model"]
feature_names = model_data["features_names"]

print(loaded_model)

print(feature_names)

input_data = {
    'gender': 'Female',
    'SeniorCitizen': 0,
    'Partner': 'Yes',
    'Dependents': 'No',
    'tenure': 1,
    'PhoneService': 'No',
    'MultipleLines': 'No phone service',
    'InternetService': 'DSL',
    'OnlineSecurity': 'No',
    'OnlineBackup': 'Yes',
    'DeviceProtection': 'No',
    'TechSupport': 'No',
    'StreamingTV': 'No',
    'StreamingMovies': 'No',
    'Contract': 'Month-to-month',
    'PaperlessBilling': 'Yes',
    'PaymentMethod': 'Electronic check',
    'MonthlyCharges': 29.85,
    'TotalCharges': 29.85
}


input_data_df = pd.DataFrame([input_data])

with open("encoders.pkl", "rb") as f:
  encoders = pickle.load(f)


# encode categorical featires using teh saved encoders
for column, encoder in encoders.items():
  input_data_df[column] = encoder.transform(input_data_df[column])

# make a prediction
prediction = loaded_model.predict(input_data_df)
pred_prob = loaded_model.predict_proba(input_data_df)

print(prediction)

# results
print(f"Prediction: {'Churn' if prediction[0] == 1 else 'No Churn'}")
print(f"Prediciton Probability: {pred_prob}")

encoders

df.head()

from sklearn.metrics import(accuracy_score,precision_score,recall_score,f1_score,confusion_matrix,classification_report,roc_auc_score)
import matplotlib.pyplot as plt
import seaborn as sns

y_pred = loaded_model.predict(X_test)
y_prob = loaded_model.predict_proba(X_test)[:, 1]

acc = accuracy_score(y_test, y_pred)
prec = precision_score(y_test, y_pred)
rec = recall_score(y_test, y_pred)
roc = roc_auc_score(y_test, y_prob)

print("Accuracy:", round(acc, 3))
print("Precision:", round(prec, 3))
print("Recall:", round(rec, 3))
print("ROC AUC:", round(roc, 3))

print("\nClassification Report:\n")
print(classification_report(y_test, y_pred))

cm = confusion_matrix(y_test,y_pred)
plt.figure(figsize=(5,4))
sns.heatmap(cm, annot=True,fmt='d',cmap='Blues',xticklabels=['No yes'],yticklabels=['No yes'])
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix')
plt.show()

from sklearn.metrics import roc_curve, auc

fpr, tpr, thr = roc_curve(y_test, y_prob)
roc_auc = auc(fpr, tpr)

plt.figure()
plt.plot(fpr, tpr, label=f'ROC curve (AUC = {roc_auc:.3f})')
plt.plot([0,1], [0,1], linestyle='--')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('ROC Curve')
plt.legend(loc='lower right')
plt.show()

def evaluate_threshold(threshold):
    y_pred_thresh = (y_prob >= threshold).astype(int)
    return {
        'threshold': threshold,
        'precision': precision_score(y_test, y_pred_thresh),
        'recall': recall_score(y_test, y_pred_thresh),

    }

for t in [0.3, 0.4, 0.5, 0.6]:
    print(evaluate_threshold(t))

from sklearn.model_selection import cross_val_score
cv_scores = cross_val_score(loaded_model, X_train, y_train, cv=5,)
print("CV F1 mean:", np.mean(cv_scores), "std:", np.std(cv_scores))

import joblib
joblib.dump(loaded_model, 'churn_pipeline_v1.joblib')

model = joblib.load('churn_pipeline_v1.joblib')

def predict_single(input_df, model):
    # input_df: single-row pandas DataFrame with same columns as training data (raw values)
    prob = model.predict_proba(input_df)[:,1][0]
    pred = model.predict(input_df)[0]
    label = 'Churn' if pred==1 else 'No Churn'
    return {'label': label, 'probability': prob}

# Example:
# print(predict_single(sample_df, model))

!pip install streamlit pyngrok scikit-learn pandas
joblib

from pyngrok import ngrok
# Replace "YOUR_NGROK_AUTH_TOKEN" with your actual ngrok authentication token
ngrok.set_auth_token("3592MB9cee10wjRufJPKIQyWsHy_4MWdxxPrmuNXU1rgC6zgU")

import streamlit as st
import pandas as pd
import pickle
with open('/content/style.css') as f:
  st.markdown(f"<style>{f.read()}</style>",unsafe_allow_html=True)

st.title("üíú Customer Churn Prediction ")
st.markdown("### Your mini-project just got a glow-up ‚ú®")

#sidebar chart example
st.sidebar.header("üìä Insights Panel")
chart_data = pd.DataFrame({
    'Churn':['Yes','No'],
    'Count':[120,380]
})
st.sidebar.bar_chart(chart_data.set_index('Churn'))

#input section
st.subheader("üîç Enter Customer Details")


gender = st.selectbox("Gender", ["Male", "Female"])
SeniorCitizen = st.selectbox("Senior Citizen", [0, 1])
Partner = st.selectbox("Partner", ["Yes", "No"])
Dependents = st.selectbox("Dependents", ["Yes", "No"])
tenure = st.number_input("Tenure (months)", min_value=0)
PhoneService = st.selectbox("Phone Service", ["Yes", "No"])
MultipleLines = st.selectbox("Multiple Lines", ["Yes", "No", "No phone service"])
InternetService = st.selectbox("Internet Service", ["DSL", "Fiber optic", "No"])
OnlineSecurity = st.selectbox("Online Security", ["Yes", "No", "No internet service"])
OnlineBackup = st.selectbox("Online Backup", ["Yes", "No", "No internet service"])
DeviceProtection = st.selectbox("Device Protection", ["Yes", "No", "No internet service"])
TechSupport = st.selectbox("Tech Support", ["Yes", "No", "No internet service"])
StreamingTV = st.selectbox("Streaming TV", ["Yes", "No", "No internet service"])
StreamingMovies = st.selectbox("Streaming Movies", ["Yes", "No", "No internet service"])
Contract = st.selectbox("Contract", ["Month-to-month", "One year", "Two year"])
PaperlessBilling = st.selectbox("Paperless Billing", ["Yes", "No"])
PaymentMethod = st.selectbox("Payment Method", ["Electronic check", "Mailed check", "Bank transfer (automatic)", "Credit card (automatic)"])
MonthlyCharges = st.number_input("Monthly Charges", min_value=0.0)
TotalCharges = st.number_input("Total Charges", min_value=0.0)


# Load the model and encoders
with open("/content/customer_churn_model.pkl", "rb") as f:
    model_data = pickle.load(f)

loaded_model = model_data["model"]

with open("encoders.pkl", "rb") as f:
    encoders = pickle.load(f)

if st.button("Predict Churn"):
    input_data = {
        'gender': gender,
        'SeniorCitizen': SeniorCitizen,
        'Partner': Partner,
        'Dependents': Dependents,
        'tenure': tenure,
        'PhoneService': PhoneService,
        'MultipleLines': MultipleLines,
        'InternetService': InternetService,
        'OnlineSecurity': OnlineSecurity,
        'OnlineBackup': OnlineBackup,
        'DeviceProtection': DeviceProtection,
        'TechSupport': TechSupport,
        'StreamingTV': StreamingTV,
        'StreamingMovies': StreamingMovies,
        'Contract': Contract,
        'PaperlessBilling': PaperlessBilling,
        'PaymentMethod': PaymentMethod,
        'MonthlyCharges': MonthlyCharges,
        'TotalCharges': TotalCharges
    }

    input_df = pd.DataFrame([input_data])

    # Encode categorical features using the saved encoders
    for column, encoder in encoders.items():
        if column in input_df.columns:
            input_df[column] = encoder.transform(input_df[column])

    # make a prediction
    prediction = loaded_model.predict(input_df)
    pred_prob = loaded_model.predict_proba(input_df)


    st.write("Prediction:", "Churn" if prediction[0] == 1 else "No Churn")
    st.write(f"Prediction Probability: {pred_prob[0][1]:.2f}")

import joblib
import pandas as pd
import streamlit as st
loaded=joblib.load('/content/churn_pipeline_v1.joblib')
if isinstance(loaded,dict):
  if 'model' in loaded:
    model=loaded['model']
    st.write("Loaded model from dictionary")
  else:
    st.write("Dictionary is found but no model key!")
    model=list(loaded.values()[0])
else:
  model=loaded
  st.write("Loaded model directly")
st.write("Model type:",type(model))

print(type(model))
print(model)

import joblib
loaded=joblib.load("/content/churn_pipeline_v1.joblib")
print("type of loaded object:",type(loaded))
if isinstance(loaded,dict):
  print("keys in dict:",loaded.keys())
  for key,value in loaded.items():
    print(f"Key:{key}|Type:{type(value)}")

with open('app.py', 'w') as f:
    f.write("""
import streamlit as st
import pandas as pd
import joblib
import pickle

# Load model
# The model is directly loaded from the joblib file
loaded_model = joblib.load('churn_pipeline_v1.joblib')

# Load encoders
with open("encoders.pkl", "rb") as f:
    encoders = pickle.load(f)

# Load CSS
with open("/content/style.css") as f:
    st.markdown(f"<style>{f.read()}</style>", unsafe_allow_html=True)

# ---------------------- UI HEADER ----------------------
st.title("üíú Customer Churn Prediction Dashboard")
st.markdown("### Your mini-project just got a glow-up ‚ú®")

# ---------------------- Sidebar Charts Example ----------------------
st.sidebar.header("üìä Insights Panel")

# Example: Show sample churn rates (replace with your EDA charts later)
chart_data = pd.DataFrame({
    'Churn': ['Yes', 'No'],
    'Count': [120, 380]
})

st.sidebar.bar_chart(chart_data.set_index('Churn'))

# ---------------------- INPUT SECTION ----------------------
st.subheader("üîç Enter Customer Details")

gender = st.selectbox("Gender", ["Male", "Female"])
SeniorCitizen = st.selectbox("Senior Citizen", [0, 1])
Partner = st.selectbox("Partner", ["Yes", "No"])
Dependents = st.selectbox("Dependents", ["Yes", "No"])
tenure = st.number_input("Tenure (months)", min_value=0)
PhoneService = st.selectbox("Phone Service", ["Yes", "No"])
MultipleLines = st.selectbox("Multiple Lines", ["Yes", "No", "No phone service"])
InternetService = st.selectbox("Internet Service", ["DSL", "Fiber optic", "No"])
OnlineSecurity = st.selectbox("Online Security", ["Yes", "No", "No internet service"])
OnlineBackup = st.selectbox("Online Backup", ["Yes", "No", "No internet service"])
DeviceProtection = st.selectbox("Device Protection", ["Yes", "No", "No internet service"])
TechSupport = st.selectbox("Tech Support", ["Yes", "No", "No internet service"])
StreamingTV = st.selectbox("Streaming TV", ["Yes", "No", "No internet service"])
StreamingMovies = st.selectbox("Streaming Movies", ["Yes", "No", "No internet service"])
Contract = st.selectbox("Contract", ["Month-to-month", "One year", "Two year"])
PaperlessBilling = st.selectbox("Paperless Billing", ["Yes", "No"])
PaymentMethod = st.selectbox("Payment Method", ["Electronic check", "Mailed check", "Bank transfer (automatic)", "Credit card (automatic)"])
MonthlyCharges = st.number_input("Monthly Charges", min_value=0.0)
TotalCharges = st.number_input("Total Charges", min_value=0.0)

if st.button("Predict Churn"):
    # Convert inputs for model
    input_data=  {
        'gender': gender,
        'SeniorCitizen': SeniorCitizen,
        'Partner': Partner,
        'Dependents': Dependents,
        'tenure': tenure,
        'PhoneService': PhoneService,
        'MultipleLines': MultipleLines,
        'InternetService': InternetService,
        'OnlineSecurity': OnlineSecurity,
        'OnlineBackup': OnlineBackup,
        'DeviceProtection': DeviceProtection,
        'TechSupport': TechSupport,
        'StreamingTV': StreamingTV,
        'StreamingMovies': StreamingMovies,
        'Contract': Contract,
        'PaperlessBilling': PaperlessBilling,
        'PaymentMethod': PaymentMethod,
        'MonthlyCharges': MonthlyCharges,
        'TotalCharges': TotalCharges
    }

    # Create DataFrame from a list containing the input dictionary for a single row
    input_df = pd.DataFrame([input_data])

    # Encode categorical features using the saved encoders
    for column, encoder in encoders.items():
        if column in input_df.columns:
            input_df[column] = encoder.transform(input_df[column])

    # make a prediction
    prediction = loaded_model.predict(input_df)
    pred_prob = loaded_model.predict_proba(input_df)


    st.write("Prediction:", "Churn" if prediction[0] == 1 else "No Churn")
    st.write(f"Prediction Probability: {pred_prob[0][1]:.2f}")"""
    )

model.feature_names_in_

!streamlit run app.py --server.enableCORS false --server.enableXsrfProtection false

X.columns

!pip install streamlit pyngrok
from pyngrok import ngrok

public_url = ngrok.connect(8501)
print("Public URL:", public_url)
!streamlit run app.py --server.port 8501 --server.enableCORS false --server.enableXsrfProtection false